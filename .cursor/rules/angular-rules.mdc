---
description:
globs:
alwaysApply: true
---
# Contexte et Objectif de l'Application

L'objectif principal de cette application est de servir de site vitrine pour la vente de chiots "frenchie". Le site vise à :

- Présenter les chiots disponibles à la vente.
- Afficher des informations sur les parents des chiots.
- Fournir une section "Qui sommes-nous" pour établir la confiance.
- Inclure un blog avec des articles sur l'entretien des chiens, mettant en avant notre expertise dans le domaine.
- Faciliter la vente des chiots en mettant en valeur leur qualité et le sérieux de l'élevage.

Toutes les développements et modifications doivent être orientés vers l'accomplissement de ces objectifs, en créant une expérience utilisateur agréable et informative pour les futurs acheteurs potentiels.

# Structure de Projet

Ce projet suit une structure organisée pour les différents types de fichiers :

- Les composants, services, models, etc. spécifiques à une fonctionnalité résident dans `src/app/features/<nom-fonctionnalite>/`.
- Les composants visuels, directives, pipes et autres éléments réutilisables partagés entre plusieurs fonctionnalités se trouvent dans `src/app/shared/`.
- Les services singletons, gardes, intercepteurs et models globaux ou partagés par l'ensemble de l'application sont placés dans `src/app/core/`.

Lorsque de nouveaux fichiers sont créés, ils doivent être placés dans le répertoire approprié selon cette structure.

# Stack Technique du Projet

Ce projet est développé en utilisant la stack technique suivante :

- **Framework Frontend :** Angular 19
- **Architecture Angular :** Utilisation exclusive des Standalone Components (pas de modules) et de la nouvelle syntaxe de flux de contrôle (`@if`, `@for`, `@switch`).
- **Styling :** Tailwind CSS 4 avec la librairie de composants DaisyUI 5.
- **Fonctionnalités clés :** Support du mode sombre (Dark Theme) et Internationalisation (i18n) pour le français et l'anglais.

Toute contribution ou modification doit respecter l'utilisation de ces technologies et paradigmes de développement.

# Utilisation du serveur MCP context7 pour avoir la doc à jour

Lorsque des informations à jour sur des bibliothèques ou technologies spécifiques au projet sont nécessaires, il faut utiliser le serveur MCP context7. Le processus implique deux étapes :

1.  Utiliser l'outil `resolve-library-id` pour trouver l'identifiant compatible Context7 de la bibliothèque.
2.  Utiliser l'outil `get-library-docs` avec l'identifiant obtenu pour récupérer la documentation pertinente.

Cette approche garantit que les informations utilisées pour le développement sont basées sur les versions actuelles et la configuration du projet.

# Conventions pour les Composants Angular

- **Templates et Styles Inline par Défaut :** Pour favoriser la colocation et la lisibilité des petits et moyens composants, les templates et les styles doivent être définis inline dans le fichier `.ts` du composant.
    - La génération de nouveaux composants est configurée pour utiliser des templates inline et ne pas créer de fichiers de style séparés.
    - L'utilisation de Tailwind CSS doit être privilégiée pour minimiser la quantité de styles spécifiques au composant.

- **Exception pour la Complexité :**
    - Si le contenu du template inline d'un composant dépasse **500 lignes**, il peut être extrait dans un fichier `.html` séparé (`templateUrl`).
    - Si les styles inline (hors classes Tailwind) deviennent excessivement longs et nuisent à la lisibilité du fichier `.ts` (par exemple, plus de 100-150 lignes de CSS pur), ils peuvent être extraits dans un fichier de styles séparé (`styleUrls`).
    - Cette décision doit être prise au cas par cas, en privilégiant toujours la maintenabilité et la clarté.

# Organisation et Réutilisabilité

## Extraction et Centralisation des Éléments Réutilisables

- **Composants Réutilisables :** Tout composant utilisé dans plus d'une fonctionnalité doit être extrait vers `src/app/shared/components/`.
    - Exemples dans le projet : `LoadingStateComponent`, `SlotComponent`, `SocialLinksComponent`, `CloudinaryImageComponent`.
    - Les composants complexes avec des sous-composants doivent être organisés dans des sous-dossiers dédiés (exemple : `cloudinary-image/`).

- **Directives Réutilisables :** Les directives utilitaires doivent être placées dans `src/app/shared/directives/`.
    - Exemples : `IntersectionObserverDirective`, `ScrollListenerDirective`, `LoadingStateDirective`.
    - Toutes les directives doivent être standalone et utiliser le préfixe `app`.

- **Opérateurs RxJS Custom :** Les opérateurs RxJS personnalisés doivent être centralisés dans `src/app/shared/rxjs/`.
    - Exemple : `withLoadingState` operator pour la gestion cohérente des états de chargement.

- **Constantes Globales :** Toutes les constantes partagées doivent être placées dans `src/app/core/constants/`.
    - Structure typée avec interfaces TypeScript (exemple : `routes.constants.ts`, `social-links.constants.ts`).
    - Utiliser `$localize` pour les textes internationalisés directement dans les constantes.

# Conventions de Nommage et Structure

## Alias de Chemins TypeScript

- **Utilisation Systématique des Alias :**
    - `@/` pour tous les imports depuis `src/app/`
    - `~/` pour tous les imports depuis `src/`
    - Éviter absolument les imports relatifs longs (`../../../`) en faveur des alias

## Organisation des Composants Complexes

- **Sous-dossiers pour Composants avec Dépendances :**
    - Les composants avec des sous-composants doivent être organisés dans des sous-dossiers dédiés
    - Exemple : `header/` contient `desktop-nav/` et `mobile-nav/`
    - Chaque composant doit avoir son fichier de test `.spec.ts` dans le même dossier

## Gestion d'État

- **NgRx Signals pour l'État Global :**
    - Utiliser NgRx Signals exclusivement pour la gestion d'état globale
    - Placer tous les stores dans `src/app/core/stores/`
    - Fournir les stores au niveau root avec `{ providedIn: 'root' }`
    - Nommer les stores avec le suffixe `.store.ts`

# Patterns de Développement

## Composition et Templates

- **Patterns de Composition Avancés :**
    - Privilégier la composition avec `@ContentChild` et `TemplateRef` pour créer des composants flexibles
    - Utiliser des templates de fallback pour les cas où le contenu n'est pas fourni
    - Implémenter des slots nommés pour une meilleure organisation du contenu (voir `SlotComponent`)

## Gestion des États de Chargement

- **Pattern LoadingState Unifié :**
    - Utiliser systématiquement l'opérateur `withLoadingState()` pour tous les appels asynchrones
    - Combiner avec le `LoadingStateComponent` pour une UX cohérente
    - Fournir des templates personnalisés pour les états de chargement et d'erreur quand nécessaire
    - Structure d'interface standardisée : `{ data: T | null, loading: boolean, error: string | null }`

## Internationalisation

- **Conventions i18n Strictes :**
    - Utiliser `$localize` pour toutes les chaînes de caractères visibles par l'utilisateur
    - Structure hiérarchique des clés : `@@route.title.home`, `@@social.facebook`, `@@common.loading`
    - Centraliser les textes traduits dans les fichiers de constantes quand approprié
    - Support français (FR) et anglais (EN) obligatoire

# Configuration et Outils

## Linting et Formatage

- **Standards de Code Stricts :**
    - Respecter la configuration ESLint avec les préfixes `app-` pour tous les composants et directives
    - Utiliser Prettier avec configuration : 100 caractères de largeur, tabulations 4 espaces, quotes simples
    - Appliquer automatiquement le formatage Tailwind CSS via `prettier-plugin-tailwindcss`
    - Interdire `console.log` et `debugger` en production

## Gestion des Dépendances

- **Standards de Packages :**
    - Utiliser `pnpm` exclusivement comme gestionnaire de packages
    - Maintenir les versions Angular alignées (core, common, router, etc.)
    - Séparer clairement les dépendances de production et de développement
    - Versions fixes pour éviter les conflits

## Services et Injection

- **Patterns d'Injection Modernes :**
    - Fournir les services au niveau approprié (root pour les singletons, component pour les services locaux)
    - Implémenter des interfaces TypeScript strictes pour tous les modèles de données
    - Placer les modèles globaux dans `src/app/core/models/`

# Optimisation et Performance

## Images et Assets

- **Gestion des Images Optimisée :**
    - Utiliser systématiquement `CloudinaryImageComponent` pour toutes les images
    - Configurer les images prioritaires avec `isPriority="true"` pour les images above-the-fold
    - Définir des tailles appropriées avec l'attribut `sizes` pour les images responsives
    - Provider Cloudinary configuré au niveau composant

## Détection de Changements et SSR

- **Optimisations Performance :**
    - Utiliser `ChangeDetectionStrategy.OnPush` pour tous les composants réutilisables
    - Implémenter des Signals pour la réactivité moderne
    - Vérifier la compatibilité avec le SSR via `isPlatformBrowser()` pour toutes les APIs du navigateur
    - Injecter `PLATFORM_ID` pour les vérifications de plateforme

## Directives et Observateurs

- **Patterns d'Observation :**
    - Implémenter `OnDestroy` pour tous les observateurs (IntersectionObserver, etc.)
    - Utiliser des Signals en lecture seule pour exposer l'état des directives
    - Nettoyer tous les observateurs dans `ngOnDestroy()`
    - Vérifier la plateforme browser avant d'utiliser les APIs natives



